<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="你好，我是米歐，歡迎來到我的部落格:)"><meta property="og:title" content="MMiooiMM"><meta property="og:description" content="你好，我是米歐，歡迎來到我的部落格:)"><meta property="og:image" content="https://raw.githubusercontent.com/MMiooiMM/MMiooiMM.github.io/master/images/VeryImportantFile.jpg"><title>.NET 後端起手式 30天認識 C# - Day 21 迭代器 | MMiooiMM</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="/css/mio.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 4.2.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/2019-iT-%E9%82%A6%E5%B9%AB%E5%BF%99%E9%90%B5%E4%BA%BA%E8%B3%BD/" rel="tag">2019 iT 邦幫忙鐵人賽</a><a class="post-tag-link" href="/tags/CSharp/" rel="tag">CSharp</a></div><div class="post-time">2018-10-31</div></div></div><div class="container post-header"><h1>.NET 後端起手式 30天認識 C# - Day 21 迭代器</h1></div><div class="container post-content"><h2 id="DAY-21-迭代器"><a href="#DAY-21-迭代器" class="headerlink" title="DAY 21 迭代器"></a>DAY 21 迭代器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器我找不到一個好的解釋，所以請看完本文後自行領悟吧。</p>
<p>迭代器的關鍵字 yield，只有在傳回值為 IEnumerator<T> 或者 IEnumerable<T> 類型的方法才可以使用，傳回時是以 yield return 而不能只是 return 單一關鍵字，且方法不能夠使用 ref 或 out 參數。如果要停止迭代的話可以使用 yield break。</p>
<p>然而各位還記得 DAY 05 的 foreach 吧，foreach 的逐一查看陣列、集合中的元素就是透過今天要介紹的迭代器。</p>
<p>foreach 有些集合類別能用，有些不能使用，差別在於有無實作 IEnumerator<T> 或者 IEnumerable<T> 這兩個介面，雖然系列文講到現在的內容，是不會發生這種問題。</p>
<p>我們來簡單的示範什麼是迭代器，所先建立一個傳回 IEnumerable<T> 的方法，並且使用這個方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> strs = GetStrings ();</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="keyword">var</span> str <span class="keyword">in</span> strs)</span><br><span class="line">    Console.WriteLine (str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="keyword">string</span>&gt; <span class="title">GetStrings</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"Mio"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"Miffy"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"Lulu"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">"NekoSan"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以下中斷點來看一下程式的執行過程，這樣比較好了解迭代器做了什麼，你可以看到程式執行過程，不斷的跳來跳去。</p>
<p>迭代器主要是實現 IEnumerator 介面來執行，成員為 Current 與 MoveNext ()，你可以想像成一個集合內，Current 代表目前元素，MoveNext () 為檢查有無下個元素。當程式呼叫迭代器時，他會先檢查 MoveNext ()，如果有則移動 Current，直到沒有下一個元素。</p>
<p>但上述方法只是簡單的示範 yield 運作模式，無實作 IEnumerator 介面，你可以先當作 yield return 為傳回一個 Current，如果有下一句 yield return 則 MoveNext () 為 true，然而碰到 yield break 則結束迭代。</p>
<p>除此之外也可以看到，strs 在傳值給 str 時，才會開始迭代，因為迭代器有延遲執行的特性，所以在資料處理方面，與一般的情況不太一樣。以往處理資料時，是整理好一大筆符合資料後才傳回，但迭代器則是出現一筆符合資料的就傳回，直到該集合逐一檢查完成。</p>
<p>再來我們以 DAY 18 的 Node 來進行改造，讓他可以使用 foreach，但在此之前要先說一聲抱歉，我那天寫的時候可能神智不清楚，所以在操作 Node 時的範例不是很洽當，但還是可以當作泛型的介紹，所以我們重新來建立新的 Node</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt; nodes = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt; (<span class="number">2</span>);</span><br><span class="line">    nodes.Next = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt; (<span class="number">6</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Node&lt;T&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    Value = <span class="keyword">default</span> (T);</span><br><span class="line">    Next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span> (<span class="params">T <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    Value = <span class="keyword">value</span>;</span><br><span class="line">    Next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> T Value;</span><br><span class="line">  <span class="keyword">public</span> Node&lt;T&gt; Next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有發現差異點吧，沒有的同學就當沒事發生。</p>
<p>當今天要去逐一查看 Node 的內容時，我們想要重頭開始列出每一個 Node 的 value 直到 Next == null，所以我們來實作 IEnumerable<T> 介面</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    Node&lt;<span class="keyword">int</span>&gt; nodes = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt; (<span class="number">2</span>);</span><br><span class="line">    nodes.Next = <span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt; (<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> n <span class="keyword">in</span> nodes) &#123;</span><br><span class="line">      Console.WriteLine (n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Node&lt;T&gt; : IEnumerable&lt;T&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    Value = <span class="keyword">default</span> (T);</span><br><span class="line">    Next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span> (<span class="params">T <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    Value = <span class="keyword">value</span>;</span><br><span class="line">    Next = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> T Value;</span><br><span class="line">  <span class="keyword">public</span> Node&lt;T&gt; Next;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">return</span> temp.Value;</span><br><span class="line">      temp = temp.Next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  IEnumerator IEnumerable.GetEnumerator () =&gt; GetEnumerator ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>簡單的設計一下，就可以看到 foreach 能夠正確的印出 Node 裡每一個 value 值。</p>
<p>既然做了那我們來優化一下，提供一個可以知道該 Node 包含的 Node 數的 Length，並加上索引存取運算子。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Length &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> ((current = current.Next) != <span class="literal">null</span>)</span><br><span class="line">      result++;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> T <span class="keyword">this</span> [<span class="keyword">int</span> index] &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.Next != <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.Next[index - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> Value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以自行使用看看，這邊就不用在教導如何使用了吧。</p>
<h3 id="一些小結論"><a href="#一些小結論" class="headerlink" title="一些小結論"></a>一些小結論</h3><p>迭代器可以實現延遲執行，可以參考文末連結，或者自己再去找找資源補充一下，我敘述的可能有點混亂，好處也就是資料的傳回方式不一樣，可能還有其他的，但我不知道而已，可能這樣寫看起來很潮也是好處之一。</p>
<p>在最後補上的兩個方法，想說介紹一下存取子的用法，已經寫到不知道有沒有寫過了，大致上再講一遍，如果講過就當複習吧。</p>
<p>存取子可以控制屬性成員的讀寫運算機制。</p>
<p>get 為讀取，如果只有 get 如上述範例，則可以表示該屬性唯獨，並可以控制它讀取時傳回的內容。</p>
<p>set 為寫入，如果只有 set 則表示該屬性唯寫，如寫入一個數字時永遠加二這個邏輯，但個人是沒有碰過唯寫屬性的例子，如果使用一般會跟著 get 一起。</p>
<p>get &amp; set 為可讀可寫，可以控制讀取的傳回值，與設定時的邏輯。正常什麼都不做的情況預設就是 get &amp; set，但讀寫時無任何規則，單純的操作屬性而已。</p>
<p>感謝閱讀。</p>
<p>參考連結<br><a href="https://columns.chicken-house.net/2008/09/18/c-yield-return-1-how-it-work/" target="_blank" rel="noopener">[C#: yield return] #1. How It Work ? — 安德魯的部落格</a></p>
</div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'mio-blog';
var disqus_identifier = '2018/10/31/2018-10-31-learn-csharp-in-30-days-21/';
var disqus_title = '.NET 後端起手式 30天認識 C# - Day 21 迭代器';
var disqus_url = 'http://yoursite.com/2018/10/31/2018-10-31-learn-csharp-in-30-days-21/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" target="_blank" rel="noopener" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-156431110-1');ga('send','pageview');</script></body></html>