<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="你好，我是米歐，歡迎來到我的部落格:)"><meta property="og:title" content="MMiooiMM"><meta property="og:description" content="你好，我是米歐，歡迎來到我的部落格:)"><meta property="og:image" content="https://raw.githubusercontent.com/MMiooiMM/MMiooiMM.github.io/master/images/VeryImportantFile.jpg"><title>.NET 後端起手式 30天認識 C# - Day 07 方法 | MMiooiMM</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="/css/mio.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><meta name="generator" content="Hexo 4.2.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/2019-iT-%E9%82%A6%E5%B9%AB%E5%BF%99%E9%90%B5%E4%BA%BA%E8%B3%BD/" rel="tag">2019 iT 邦幫忙鐵人賽</a><a class="post-tag-link" href="/tags/CSharp/" rel="tag">CSharp</a></div><div class="post-time">2018-10-17</div></div></div><div class="container post-header"><h1>.NET 後端起手式 30天認識 C# - Day 07 方法</h1></div><div class="container post-content"><h2 id="DAY-07-方法"><a href="#DAY-07-方法" class="headerlink" title="DAY 07 方法"></a>DAY 07 方法</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote>
<p>方法是包含一系列陳述式的程式碼區塊。<br>程式會造成呼叫方法並指定任何所需的方法引數來執行陳述式。</p>
</blockquote>
<p>簡單說方法就是把你本來一長串的程式碼包起來，如果不使用方法的話，可以想像全部東西都塞在 Main 函式裡面，那這個 code 很大機率是難懂難改的。</p>
<p>題外話：個人習慣把有回傳值的 function 稱為方法，無回傳值的 function 稱為函式，只是中文的用詞不同而已，想一想我覺得先說明好了，不然一下方法一下函式，我怕新手會搞不懂，至於回傳值又是什麼後面會解釋。</p>
<p>在介紹方法前，繼續拿 99 乘法表來玩，變形一下讓使用者輸入兩個數字，列印出兩數之間的乘法表，例如輸入 5 和 7 則顯示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 * 5 &#x3D; 25  5 * 6 &#x3D; 30  5 * 7 &#x3D; 35</span><br><span class="line">6 * 5 &#x3D; 30  6 * 6 &#x3D; 36  6 * 7 &#x3D; 42</span><br><span class="line">7 * 5 &#x3D; 35  7 * 6 &#x3D; 42  7 * 7 &#x3D; 49</span><br></pre></td></tr></table></figure>

<p>先介紹如何在 Console 輸入，首先我們要先去改 <code>launch.json</code>，因為<code>console</code>預設是<code>internalConsole</code>，在 VSCode 看到的 Console 是不能輸入東西的，我們要讓他彈出來，將<code>internalConsole</code>改成<code>externalTerminal</code>就可以。</p>
<p>如果拿之前的範例程式執行，會發現彈了一下就消失，因為程式瞬間印出瞬間結束就關掉了，所以我們讓程式執行讀取使用者行為的方法<code>Console.ReadLine()</code>，這方法可以讀取使用者輸入的文字直到按下 Enter 鍵。</p>
<p>然後我們就可以來撰寫變種 99 乘法表了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine (&quot;請輸入開始的數字&quot;);</span><br><span class="line">int start &#x3D; int.Parse (Console.ReadLine ());</span><br><span class="line">Console.WriteLine (&quot;請輸入結束的數字&quot;);</span><br><span class="line">int end &#x3D; int.Parse (Console.ReadLine ());</span><br><span class="line">for (int i &#x3D; start; i &lt;&#x3D; end; i++) &#123;</span><br><span class="line">  for (int j &#x3D; start; j &lt;&#x3D; end; j++) &#123;</span><br><span class="line">    Console.Write ($&quot;&#123;i&#125; * &#123;j&#125; &#x3D; &#123;i * j&#125;\t&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  Console.Write (&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey ();</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>int 型別，int.Parse 方法我會在明天的個人常用方法介紹，除非有下中斷點使程式停住，不然執行完就會直接關閉像我上面說的，所以我在流程結束後加入```Console.ReadKey()```，這個方法所接受的是字元(char)，等同於按下任意鍵離開。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那如果我們要的是使用者輸入完後，分別印出 1 ~ end、start ~ end、start ~ 9 三種乘法表呢？</span><br><span class="line"></span><br><span class="line">如果沒有方法</span><br></pre></td></tr></table></figure>
<p>Console.WriteLine (“請輸入開始的數字”);<br>int start = int.Parse (Console.ReadLine ());<br>Console.WriteLine (“請輸入結束的數字”);<br>int end = int.Parse (Console.ReadLine ());<br>for (int i = 1; i &lt;= end; i++) {<br>  for (int j = 1; j &lt;= end; j++) {<br>    Console.Write ($”{i} * {j} = {i * j}\t”);<br>  }<br>  Console.Write (“\n”);<br>}<br>for (int i = start; i &lt;= end; i++) {<br>  for (int j = start; j &lt;= end; j++) {<br>    Console.Write ($”{i} * {j} = {i * j}\t”);<br>  }<br>  Console.Write (“\n”);<br>}<br>for (int i = start; i &lt;= 9; i++) {<br>  for (int j = start; j &lt;= 9; j++) {<br>    Console.Write ($”{i} * {j} = {i * j}\t”);<br>  }<br>  Console.Write (“\n”);<br>}<br>Console.ReadKey ();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">經過這麼多次的練習，我們知道 i 與 j 的初始值是開頭的數字，而用來判斷 i 與 j 小於等於的數字是結束的數字，所以如果有個模板是行為一樣，但只替換開頭與結束數字的話，程式碼就會乾淨許多，那就是我們所謂的 function</span><br></pre></td></tr></table></figure>
<p>static void Main (string[] args) {<br>  Console.WriteLine (“請輸入開始的數字”);<br>  int start = int.Parse (Console.ReadLine ());<br>  Console.WriteLine (“請輸入結束的數字”);<br>  int end = int.Parse (Console.ReadLine ());<br>  MultiplicationTable (1, end);<br>  MultiplicationTable (start, end);<br>  MultiplicationTable (start, 9);<br>  Console.ReadKey ();<br>}<br>static void MultiplicationTable (int start, int end) {<br>  for (int i = start; i &lt;= end; i++) {<br>    for (int j = start; j &lt;= end; j++) {<br>      Console.Write ($”{i} * {j} = {i * j}\t”);<br>    }<br>  Console.Write (“\n”);<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是不是簡單許多了？因為本來 C# 是無法在方法裡面寫方法的，所以習慣寫在外面，我會這樣說是因為現在可以了，但我怕會講太遠。我不是很想介紹 C# 成長史，所以現在不會以後也不會特地標明是多少版本之後才能使用，所以有警告訊息時請多多留意，沒意外是不會介紹 C# 7.0 以後的東西，所以範例基本上不會有問題的吧？如果有問題一樣可以留言唷～</span><br><span class="line"></span><br><span class="line">可以看到我建立了一個 MultiplicationTable 函式，有型別為 int 變數名為 start 與 end 的變數，這邊我習慣稱為參數(Parameter)，關鍵字 static 與回傳值 void 會在後面介紹，並且以括號包住我們的乘法表，所以只要有程式碼呼叫 MultiplicationTable 函式並給予 start 與 end 兩個數字，就可以印出乘法表了。</span><br><span class="line"></span><br><span class="line">所以我覺得方法可以拆成幾個重點</span><br><span class="line"></span><br><span class="line">#### 方法名稱</span><br><span class="line"></span><br><span class="line">一個好的方法名稱，可以讓使用時明確知道方法的用途，命名規則可以參考第二天的參考連結。</span><br><span class="line"></span><br><span class="line">#### 方法內容</span><br><span class="line"></span><br><span class="line">建議超過五行的程式碼，只要有被重複使用都應該包成一個方法，並建議依照單一職責原則來撰寫方法，方法的修改只能有一個原因，如果今天因為其他因素而修改該方法，則分離該因素並重建一個方法。</span><br><span class="line"></span><br><span class="line">#### 修飾詞</span><br><span class="line"></span><br><span class="line">如範例方法的 static，之後會有更詳細的介紹</span><br><span class="line"></span><br><span class="line">#### 參數(Parameter)</span><br><span class="line"></span><br><span class="line">可以傳入任何東西也可以不傳，可供方法使用該參數內容，在第二天也有說明變數數傳遞時的行為，方法參數關鍵字依照官方的解釋</span><br><span class="line"></span><br><span class="line">&gt; params 指定這個參數可以接受可變數目的引數。</span><br><span class="line">&gt; in 指定這個參數是傳址方式傳遞，但只會由所呼叫的方法讀取。</span><br><span class="line">&gt; ref 指定這個參數是傳址方式傳遞，且可以由所呼叫的方法讀取或寫入。</span><br><span class="line">&gt; out 指定這個參數是傳址方式傳遞，且由所呼叫的方法寫入。</span><br><span class="line"></span><br><span class="line">不是很想寫出方法參數關鍵字的，有點難解釋，後面三個比較廣泛使用，如果後面有提到再特別介紹，不然系列文到今天所學的要介紹完整，不只讀者難懂我也難寫。</span><br><span class="line"></span><br><span class="line">參數可以有預設值，當今天其他程式碼呼叫該方法時可以不帶任何引數</span><br></pre></td></tr></table></figure>
<p>static void Main (string[] args) {<br>  MultiplicationTable ();<br>  Console.ReadKey ();<br>}<br>static void MultiplicationTable (int start = 5, int end = 8) {<br>  for (int i = start; i &lt;= end; i++) {<br>    for (int j = start; j &lt;= end; j++) {<br>      Console.Write ($”{i} * {j} = {i * j}\t”);<br>    }<br>  Console.Write (“\n”);<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到因為有預設值，所以可以印出從 5 開始到 8 結尾的乘法表。</span><br><span class="line"></span><br><span class="line">要注意的是帶有預設值的參數需放在沒有預設值的參數後面，沒有預設值的參數在方法被呼叫時一定要帶入相符合的引數。</span><br><span class="line"></span><br><span class="line">#### 傳回值</span><br><span class="line"></span><br><span class="line">可以傳回任何東西也可以不傳回，不傳回時需使用 void 這個關鍵字來指定方法不要傳回值，像我們的乘法表我使用了 void，你也可以傳回一個數字，如一個將數字兩者相加的方法</span><br></pre></td></tr></table></figure>
<p>static void Main (string[] args) {<br>  int number = Add (5, 6);<br>  Console.WriteLine (number);<br>}<br>static int Add (int a1, int a2) {<br>  return a1 + a2;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">跳躍陳述式 **return** 可以寫在方法任何一個地方，只要方法執行到 return 則會離開方法，即便是 void 的不傳回值也可以用 return 來離開方法，但有傳回值一定要有 return + 正確的傳回型別。</span><br><span class="line"></span><br><span class="line">#### 引數(Argument)</span><br><span class="line"></span><br><span class="line">function 內的內容都解釋過一遍了才對啊？為什麼會特別介紹引數呢？引數又是什麼？</span><br><span class="line"></span><br><span class="line">引數是將內容丟給方法的變數，所以是在呼叫方法時我們能做一些特別的，那就是具名引數與選擇性引數。</span><br><span class="line"></span><br><span class="line">**具名引數**：如果將參數名稱註明出來便可以無視參數排列規則</span><br></pre></td></tr></table></figure>
<p>static void Main (string[] args) {<br>  MultiplicationTable (end: 5, start: 2);<br>  Console.ReadKey ();<br>}<br>static void MultiplicationTable (int start, int end) {<br>  for (int i = start; i &lt;= end; i++) {<br>    for (int j = start; j &lt;= end; j++) {<br>      Console.Write ($”{i} * {j} = {i * j}\t”);<br>    }<br>  Console.Write (“\n”);<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**選擇性引數**：我認為是結合參數的預設值與具名引數，需帶有預設值的參數才能使用選擇性引數，因為有預設值所以我們可以選擇哪些參數要用具名引數帶入</span><br></pre></td></tr></table></figure>
<p>static void Main (string[] args) {<br>  MultiplicationTable (2, end: 9);<br>  Console.ReadKey ();<br>}<br>static void MultiplicationTable (int unused1, int unused2 = 3, int start = 5, int end = 8) {<br>  for (int i = start; i &lt;= end; i++) {<br>    for (int j = start; j &lt;= end; j++) {<br>      Console.Write ($”{i} * {j} = {i * j}\t”);<br>    }<br>  Console.Write (“\n”);<br>  }<br>}</p>
<pre><code>
方法的參數不一定要有用到才宣告，像上面我多了兩個無用的參數，透過使用選擇性引數，無預設值的參數需放在前面，所以第一個引數 2 為參數 unused1 所用，而具名引數 end 當然是給參數 end 使用。

### 一些小結論

雖然修飾詞與方法參數關鍵字都沒有說明，但現階段可以算是了解一個 function 的使用方式與時機，還有名詞的差異，如果關於方法有任何問題都可以留言喔～

感謝閱讀。

參考連結
[方法 (C# 程式設計手冊) | Microsoft Docs]
[方法參數 (C# 參考) | Microsoft Docs]

[方法 (C# 程式設計手冊) | Microsoft Docs]: https://docs.microsoft.com/zh-tw/dotnet/csharp/programming-guide/classes-and-structs/methods
[方法參數 (C# 參考) | Microsoft Docs]:https://docs.microsoft.com/zh-tw/dotnet/csharp/language-reference/keywords/method-parameters</code></pre></div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'mio-blog';
var disqus_identifier = '2018/10/17/2018-10-17-learn-csharp-in-30-days-07/';
var disqus_title = '.NET 後端起手式 30天認識 C# - Day 07 方法';
var disqus_url = 'http://yoursite.com/2018/10/17/2018-10-17-learn-csharp-in-30-days-07/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" target="_blank" rel="noopener" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-156431110-1');ga('send','pageview');</script></body></html>